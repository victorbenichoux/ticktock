{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ticktock Simple Python code metering library. ticktock is a minimalist library to profile Python code, it displays timing of code snippets periodically. Installation \u00b6 ticktock is available in the PyPI repository: pip install py-ticktock Quick start \u00b6 Anywhere in your code you can use tick to start a clock, and tock to register the end of the snippet you want to time: from ticktock import tick clock = tick () # do some work clock . tock () This will print \u23f1\ufe0f [3-5] 1ms count=1 Indicating that lines 3-5 take <1ms to run. If the timed snippet is called multiple times (for example within a loop), measured times will be aggregated and printed periodically (every 2 seconds by default). As a result, the following code: from ticktock import tick for _ in range ( 1000 ): clock = tick () # do some work clock . tock () Will output: \u23f1\ufe0f [4-6] 1ms count=1000","title":"Home"},{"location":"#installation","text":"ticktock is available in the PyPI repository: pip install py-ticktock","title":"Installation"},{"location":"#quick-start","text":"Anywhere in your code you can use tick to start a clock, and tock to register the end of the snippet you want to time: from ticktock import tick clock = tick () # do some work clock . tock () This will print \u23f1\ufe0f [3-5] 1ms count=1 Indicating that lines 3-5 take <1ms to run. If the timed snippet is called multiple times (for example within a loop), measured times will be aggregated and printed periodically (every 2 seconds by default). As a result, the following code: from ticktock import tick for _ in range ( 1000 ): clock = tick () # do some work clock . tock () Will output: \u23f1\ufe0f [4-6] 1ms count=1000","title":"Quick start"},{"location":"clocks/","text":"The most important objects in ticktock are clocks, which record timing. tick and Clock \u00b6 Creating clocks with tick \u00b6 The normal way to initialize a Clock is to use the tick method: from ticktock import tick clock = tick () Which returns an instance of Clock . Calling the tock method of the Clock will record the time and return the elapsed time interval: time_interval = clock.tock() Info By default, ticktock return time intervals in nanoseconds, to change this change the timer function . tick and Clock instances \u00b6 An important feature of ticktock is that any call to tick will return the same instance of a clock. This is because Clock instances are identified by where they are defined : from ticktock import tick for _ in range ( 10 ): clock = tick () print ( id ( clock )) # will print the *same* value Note Normally, instances of objects are different everytime they are created: from ticktock import tick class A : pass for _ in range ( 10 ): instance = A () print ( id ( instance )) # will print different values Whenever a Clock is created with tick , ticktock will inspect the calling frame to determine which line in the code is being run. A consequence is that you can redefine and discard clocks as you wish. For example, the following code creates and tracks two clocks : one starting at line 3, and finishing at line 4, and the other one starting at line 6 and finishing at line 7. 1 2 3 4 5 6 7 from ticktock import tick clock = tick () clock . tock () clock = tick () clock . tock () tick parameters \u00b6 You can specify some options for each call to tick : tick ( name : str = \"\" , format : Optional [ str ] = None , timer : Optional [ Callable [[], int ]] = None , enabled : Optional [ bool ] = None , collection : Optional [ \"ClockCollection\" ] = None , frame_info : Optional [ Tuple [ str , int ]] = None ) Where: name sets a name for your clock, which you can retrieve in the tick_name key in formatters format sets a format only for this clock (it will be ignored if using a LoggingRenderer ) timer sets the timer method for this clock. Note that default formatting in ticktock expects this function to return time in nanoseconds. Defaults to timing.perf_counter_ns . enabled sets the state of the clock, if set to False , the clock will be ignored and will not be rendered (Advanced) collection sets the parent ClockCollection of this clock (Advanced) frame_info is a tuple (string and int) that is used to uniquely identify the clock. If left unset, this will be the filename and line number where tick is called Clock with multiple tock calls \u00b6 A Clock can measure times between a tick and multiple tock : intervals are measured and reported between the tick and all tock calls. For example, the clock below will track the timing between tick and first tock as well as between tick and second_tock : from ticktock import tick clock = tick ( \"tick\" ) clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" ) These will be reported as two separate lines (or two log messages). The Clock object \u00b6 You can also instantiate a Clock , and use its tick and tock methods: from ticktock.clocks import Clock clock = Clock () clock . tick () # returns the Clock instance clock . tock () # returns the time between the last tick and tock The Clock initialization has the exact same signature as tick above. clock = Clock ( \"some_name\" ) Or its parent ClockCollection : clock = Clock ( \"some_name\" , collection = my_collection ) Clock.times attribute \u00b6 Internally, Clock objects maintain a times attribute. It is a dictionary of ticktock.data.AggegateTimes dataclasses (one for each tock ) that holds statistics on the measured times. Everytime a tock is performed on the clock, it updates its estimates in the times attribute (all time values are in nanoseconds): tock_name: str the name of the tock tock_filename: str the filename where tock was called tock_line: int the line number where tock was called count: int the number of times tock was called avg_time_ns: float the running average of time intervals min_time_ns: float and max_time_ns: float the running extrema of time intervals last_time_ns: float the last measured time interval std_time_ns: float = 0 the running standard deviation of time intervals","title":"Clocks"},{"location":"clocks/#tick-and-clock","text":"","title":"tick and Clock"},{"location":"clocks/#creating-clocks-with-tick","text":"The normal way to initialize a Clock is to use the tick method: from ticktock import tick clock = tick () Which returns an instance of Clock . Calling the tock method of the Clock will record the time and return the elapsed time interval: time_interval = clock.tock() Info By default, ticktock return time intervals in nanoseconds, to change this change the timer function .","title":"Creating clocks with tick"},{"location":"clocks/#tick-and-clock-instances","text":"An important feature of ticktock is that any call to tick will return the same instance of a clock. This is because Clock instances are identified by where they are defined : from ticktock import tick for _ in range ( 10 ): clock = tick () print ( id ( clock )) # will print the *same* value Note Normally, instances of objects are different everytime they are created: from ticktock import tick class A : pass for _ in range ( 10 ): instance = A () print ( id ( instance )) # will print different values Whenever a Clock is created with tick , ticktock will inspect the calling frame to determine which line in the code is being run. A consequence is that you can redefine and discard clocks as you wish. For example, the following code creates and tracks two clocks : one starting at line 3, and finishing at line 4, and the other one starting at line 6 and finishing at line 7. 1 2 3 4 5 6 7 from ticktock import tick clock = tick () clock . tock () clock = tick () clock . tock ()","title":"tick and Clock instances"},{"location":"clocks/#tick-parameters","text":"You can specify some options for each call to tick : tick ( name : str = \"\" , format : Optional [ str ] = None , timer : Optional [ Callable [[], int ]] = None , enabled : Optional [ bool ] = None , collection : Optional [ \"ClockCollection\" ] = None , frame_info : Optional [ Tuple [ str , int ]] = None ) Where: name sets a name for your clock, which you can retrieve in the tick_name key in formatters format sets a format only for this clock (it will be ignored if using a LoggingRenderer ) timer sets the timer method for this clock. Note that default formatting in ticktock expects this function to return time in nanoseconds. Defaults to timing.perf_counter_ns . enabled sets the state of the clock, if set to False , the clock will be ignored and will not be rendered (Advanced) collection sets the parent ClockCollection of this clock (Advanced) frame_info is a tuple (string and int) that is used to uniquely identify the clock. If left unset, this will be the filename and line number where tick is called","title":"tick parameters"},{"location":"clocks/#clock-with-multiple-tock-calls","text":"A Clock can measure times between a tick and multiple tock : intervals are measured and reported between the tick and all tock calls. For example, the clock below will track the timing between tick and first tock as well as between tick and second_tock : from ticktock import tick clock = tick ( \"tick\" ) clock . tock ( \"first_tock\" ) clock . tock ( \"second_tock\" ) These will be reported as two separate lines (or two log messages).","title":"Clock with multiple tock calls"},{"location":"clocks/#the-clock-object","text":"You can also instantiate a Clock , and use its tick and tock methods: from ticktock.clocks import Clock clock = Clock () clock . tick () # returns the Clock instance clock . tock () # returns the time between the last tick and tock The Clock initialization has the exact same signature as tick above. clock = Clock ( \"some_name\" ) Or its parent ClockCollection : clock = Clock ( \"some_name\" , collection = my_collection )","title":"The Clock object"},{"location":"clocks/#clocktimes-attribute","text":"Internally, Clock objects maintain a times attribute. It is a dictionary of ticktock.data.AggegateTimes dataclasses (one for each tock ) that holds statistics on the measured times. Everytime a tock is performed on the clock, it updates its estimates in the times attribute (all time values are in nanoseconds): tock_name: str the name of the tock tock_filename: str the filename where tock was called tock_line: int the line number where tock was called count: int the number of times tock was called avg_time_ns: float the running average of time intervals min_time_ns: float and max_time_ns: float the running extrema of time intervals last_time_ns: float the last measured time interval std_time_ns: float = 0 the running standard deviation of time intervals","title":"Clock.times attribute"},{"location":"collection/","text":"Collection \u00b6 ticks and tocks are recorded in a globally defined ClockCollection defined in ticktock.collection._DEFAULT_COLLECTION . It is possible to create a different ClockCollection and use it for your ticks and tocks as so: from ticktock.collection import ClockCollection collection = ClockCollection () tick ( collection = collection ) tock ( collection = collection ) The clock collection keeps track of all the clocks with their unique ids in collection.clocks , as well as deals with the rendering. Rendering period \u00b6 ticktock renders timing information on a fixed schedule with a given period . Update the period (in seconds) of the default collection to make it render more or less often: from ticktock.collection import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( period = 10 ) set_collection ( collection = collection )","title":"Collection"},{"location":"collection/#collection","text":"ticks and tocks are recorded in a globally defined ClockCollection defined in ticktock.collection._DEFAULT_COLLECTION . It is possible to create a different ClockCollection and use it for your ticks and tocks as so: from ticktock.collection import ClockCollection collection = ClockCollection () tick ( collection = collection ) tock ( collection = collection ) The clock collection keeps track of all the clocks with their unique ids in collection.clocks , as well as deals with the rendering.","title":"Collection"},{"location":"collection/#rendering-period","text":"ticktock renders timing information on a fixed schedule with a given period . Update the period (in seconds) of the default collection to make it render more or less often: from ticktock.collection import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( period = 10 ) set_collection ( collection = collection )","title":"Rendering period"},{"location":"customize/","text":"ticktock defaults to writing clock times to sys.stderr . It is possible to change the renderer used , which is useful if you want to customize the output, or send log messages. Changing format \u00b6 It is possible to change the output of ticktock clocks by changing the format string. Setting the format string \u00b6 The format string is a regular Python format string describing the desired output. Set the format string for the current default clock using set_format . For example, to print the minimum and maximum times of a clock, one could write: from ticktock import set_format set_format ( \" {min} < {mean} < {max} \" ) Equivalently, to globally set the format string, set the TICKTOCK_DEFAULT_FORMAT environment variable. Format string keys \u00b6 The keys in the format string have to be amongst the available attributes, and will be replaced by their value at render. Keys are of two distinct types, time keys and normal keys. Time keys will be replaced by a string representing the timing value with its unit attached: mean : the average of all past time intervals std : the standard deviation of all past time intervals min : the minimum measured time max : the maximum measured time last : the last measured time count : the numer of intervals measured. Normal keys have properties related to the position of the tick or tock: name : the name of the Clock . This should be the standard way to access a name, since it correctly handles the different cases (context manager, decorator, etc.) and uses the provided name s to tick and tock tick_name : the tick name if set when calling tick tock_name : the tock name if set when calling tock tick_line : the line at which tick was called in your code tock_line : the line at which tock was called in your code tick_filename : the name of the file in which tick was called tock_filename : the name of the file in which tock was called In addition, two special cased formats are accepted too: short with just the average time and the count \"\u23f1\ufe0f [ {name} ] {mean} count= {count} \" long corresponding to \"\u23f1\ufe0f [ {name} ] {mean} ( {std} std) min= {min} max= {max} count= {count} last= {last} \" Units \u00b6 By default, ticktock renders two unit levels such that 1.3 seconds will be written as 1s300ms , or 1 day and two hours and 50 minuts will be written as 1d2h . If you need more precision, you can also set the number of units you want displayed using the max_terms keyword in set_format as so: from ticktock import set_format set_format ( max_terms = 3 ) Raw time fields \u00b6 You can access the raw (floating point) values of the time aggregates as keys in the format string as well. These are all recorded in nanoseconds (unless you specified a different timer function): avg_time_ns :the average of all past time intervals std_time_ns : the standard deviation of all past time intervals min_time_ns : the minimum measured time max_time_ns : the maximum measured time last_time_ns : the last measured time Updated lines \u00b6 By default, ticktock attempts to update the last clock lines it has displayed with the new values. However, it can be undesirable in some instandes: - it can fail if other things are being written to the stream (e.g. using print in the code, or using tqdm ), or delete printed messages - it uses ASCII contol chars, which may be unwelcome if you are writing to a file If you want ticktock to write all clocks sequentially, without attempting to update previously renderered lines, set the format with no_update=True : from ticktock import set_format set_format ( no_update = True ) Change rendering period \u00b6 By default, ticktock renders clocks with a fixed period of two seconds. This can be changed globally by using set_period : from ticktock import tick set_period ( 1 ) Internally, ticktock will render all clocks whenever the period is elapsed, and a clock's tock was called. In addition to this, rendering also occurs: at the first tock of any clock when the program exits Enabling or disabling clocks \u00b6 It is possible to disable ticktock clocks: when disabled, the intervals between ticks and tocks are no longer recorded, and will not be rendered either. With an environment variable \u00b6 Set the TICKTOCK_DISABLE environment variable to disable all clocks and their rendering. With enable/disable \u00b6 ticktock also provide functions to enable or disable all clocks (and rendering): from ticktock import tick , enable , disable def some_function (): t = tick () pass t . tock () # This call will be timed and collected some_function () disable () # This call will NOT be timed some_function () enable () # This call will be timed again some_function () Warn enable and disable act on the current default ClockCollection (as set by set_collection ) Disabling a Clock vs. disabling a ClockCollection \u00b6 Warn This is an advanced topic, and should not occur unless you set the enabled/disabled state of Clock objects directly. Both Clock and ClockCollection objects can be enabled or disabled independently via their enable / disable methods. This can be misleading if a Clock 's state does not match its ClockCollection state. Simply put, here are the gotchas: a disabled Clock will not record any timing information, but if its ClockCollection is enabled, its state will be rendered disabling and enabling a ClockCollection will set the state of all of the Clock s that are currently attached to it disabling a clock does not disable its ClockCollection","title":"Customize output"},{"location":"customize/#changing-format","text":"It is possible to change the output of ticktock clocks by changing the format string.","title":"Changing format"},{"location":"customize/#setting-the-format-string","text":"The format string is a regular Python format string describing the desired output. Set the format string for the current default clock using set_format . For example, to print the minimum and maximum times of a clock, one could write: from ticktock import set_format set_format ( \" {min} < {mean} < {max} \" ) Equivalently, to globally set the format string, set the TICKTOCK_DEFAULT_FORMAT environment variable.","title":"Setting the format string"},{"location":"customize/#format-string-keys","text":"The keys in the format string have to be amongst the available attributes, and will be replaced by their value at render. Keys are of two distinct types, time keys and normal keys. Time keys will be replaced by a string representing the timing value with its unit attached: mean : the average of all past time intervals std : the standard deviation of all past time intervals min : the minimum measured time max : the maximum measured time last : the last measured time count : the numer of intervals measured. Normal keys have properties related to the position of the tick or tock: name : the name of the Clock . This should be the standard way to access a name, since it correctly handles the different cases (context manager, decorator, etc.) and uses the provided name s to tick and tock tick_name : the tick name if set when calling tick tock_name : the tock name if set when calling tock tick_line : the line at which tick was called in your code tock_line : the line at which tock was called in your code tick_filename : the name of the file in which tick was called tock_filename : the name of the file in which tock was called In addition, two special cased formats are accepted too: short with just the average time and the count \"\u23f1\ufe0f [ {name} ] {mean} count= {count} \" long corresponding to \"\u23f1\ufe0f [ {name} ] {mean} ( {std} std) min= {min} max= {max} count= {count} last= {last} \"","title":"Format string keys"},{"location":"customize/#units","text":"By default, ticktock renders two unit levels such that 1.3 seconds will be written as 1s300ms , or 1 day and two hours and 50 minuts will be written as 1d2h . If you need more precision, you can also set the number of units you want displayed using the max_terms keyword in set_format as so: from ticktock import set_format set_format ( max_terms = 3 )","title":"Units"},{"location":"customize/#raw-time-fields","text":"You can access the raw (floating point) values of the time aggregates as keys in the format string as well. These are all recorded in nanoseconds (unless you specified a different timer function): avg_time_ns :the average of all past time intervals std_time_ns : the standard deviation of all past time intervals min_time_ns : the minimum measured time max_time_ns : the maximum measured time last_time_ns : the last measured time","title":"Raw time fields"},{"location":"customize/#updated-lines","text":"By default, ticktock attempts to update the last clock lines it has displayed with the new values. However, it can be undesirable in some instandes: - it can fail if other things are being written to the stream (e.g. using print in the code, or using tqdm ), or delete printed messages - it uses ASCII contol chars, which may be unwelcome if you are writing to a file If you want ticktock to write all clocks sequentially, without attempting to update previously renderered lines, set the format with no_update=True : from ticktock import set_format set_format ( no_update = True )","title":"Updated lines"},{"location":"customize/#change-rendering-period","text":"By default, ticktock renders clocks with a fixed period of two seconds. This can be changed globally by using set_period : from ticktock import tick set_period ( 1 ) Internally, ticktock will render all clocks whenever the period is elapsed, and a clock's tock was called. In addition to this, rendering also occurs: at the first tock of any clock when the program exits","title":"Change rendering period"},{"location":"customize/#enabling-or-disabling-clocks","text":"It is possible to disable ticktock clocks: when disabled, the intervals between ticks and tocks are no longer recorded, and will not be rendered either.","title":"Enabling or disabling clocks"},{"location":"customize/#with-an-environment-variable","text":"Set the TICKTOCK_DISABLE environment variable to disable all clocks and their rendering.","title":"With an environment variable"},{"location":"customize/#with-enabledisable","text":"ticktock also provide functions to enable or disable all clocks (and rendering): from ticktock import tick , enable , disable def some_function (): t = tick () pass t . tock () # This call will be timed and collected some_function () disable () # This call will NOT be timed some_function () enable () # This call will be timed again some_function () Warn enable and disable act on the current default ClockCollection (as set by set_collection )","title":"With enable/disable"},{"location":"customize/#disabling-a-clock-vs-disabling-a-clockcollection","text":"Warn This is an advanced topic, and should not occur unless you set the enabled/disabled state of Clock objects directly. Both Clock and ClockCollection objects can be enabled or disabled independently via their enable / disable methods. This can be misleading if a Clock 's state does not match its ClockCollection state. Simply put, here are the gotchas: a disabled Clock will not record any timing information, but if its ClockCollection is enabled, its state will be rendered disabling and enabling a ClockCollection will set the state of all of the Clock s that are currently attached to it disabling a clock does not disable its ClockCollection","title":"Disabling a Clock vs. disabling a ClockCollection"},{"location":"rendering/","text":"Advanced rendering \u00b6 This section describes how to specify the exact renderer objects used by ticktock : A StandardRenderer to print to a file, or even more control on the output A LoggingRenderer to send log messages Specifying a renderer \u00b6 In ticktock , each ticktock ClockCollection object has a renderer attribute that controls how the clocks are rendered. Create your own ClockCollection with a custom renderer to customiwe the way ticktock renders your clocks. Then, set it as the default collection so all your tick s and tock s are attached to it: from ticktock.collection import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( renderer = renderers . StandardRenderer ()) set_collection ( collection = collection ) Standard renderer \u00b6 The StandardRenderer is used by default and prints to stdout: StandardRenderer ( format : Optional [ str ] = None , out : TextIO = sys . stderr , max_terms : int = 2 ) format is a regular Python format string describing the desired output. See format strings out is a text IO stream to write to max_terms controls the number of units to display. 1.3 seconds will be written as 1s with max_terms = 1 or 1s300ms with max_terms = 2 Logging renderer \u00b6 The LoggingRenderer is used to render timing information as log messages instead of printing: LoggingRenderer ( logger = None , level : str = \"INFO\" , extra_as_kwargs : bool = False ) This will make ticktock render all statistics as log messages of the given log level. Statistics are passed as a dictionary to the extra attribute of the logger by default. As a result you should make sure that your logging handler and formatter correctly outputs the contents of the extra dictionary. If your logger accepts keyword arguments to the logging functions (for example with structlog ), provide your own logger and set extra_as_kwargs to True .","title":"Renderer"},{"location":"rendering/#advanced-rendering","text":"This section describes how to specify the exact renderer objects used by ticktock : A StandardRenderer to print to a file, or even more control on the output A LoggingRenderer to send log messages","title":"Advanced rendering"},{"location":"rendering/#specifying-a-renderer","text":"In ticktock , each ticktock ClockCollection object has a renderer attribute that controls how the clocks are rendered. Create your own ClockCollection with a custom renderer to customiwe the way ticktock renders your clocks. Then, set it as the default collection so all your tick s and tock s are attached to it: from ticktock.collection import ClockCollection , set_collection from ticktock import renderers collection = ClockCollection ( renderer = renderers . StandardRenderer ()) set_collection ( collection = collection )","title":"Specifying a renderer"},{"location":"rendering/#standard-renderer","text":"The StandardRenderer is used by default and prints to stdout: StandardRenderer ( format : Optional [ str ] = None , out : TextIO = sys . stderr , max_terms : int = 2 ) format is a regular Python format string describing the desired output. See format strings out is a text IO stream to write to max_terms controls the number of units to display. 1.3 seconds will be written as 1s with max_terms = 1 or 1s300ms with max_terms = 2","title":"Standard renderer"},{"location":"rendering/#logging-renderer","text":"The LoggingRenderer is used to render timing information as log messages instead of printing: LoggingRenderer ( logger = None , level : str = \"INFO\" , extra_as_kwargs : bool = False ) This will make ticktock render all statistics as log messages of the given log level. Statistics are passed as a dictionary to the extra attribute of the logger by default. As a result you should make sure that your logging handler and formatter correctly outputs the contents of the extra dictionary. If your logger accepts keyword arguments to the logging functions (for example with structlog ), provide your own logger and set extra_as_kwargs to True .","title":"Logging renderer"},{"location":"using_clocks/","text":"Advanced timing \u00b6 ticktock gives you different ways to specify which parts of your code you want to time: functions, a decorator, or a context manager. tick and tock \u00b6 Use tick to create a Clock and signal the start of a measurement: from ticktock import tick t = tick () # t is a Clock instance Then, use the tock method to signal the end of the measurement for this clock: t . tock () Naming By default, tick creates a clock named after where it is first created (e.g. path/to/the/code.py:line_number ), and tock is named after the line in which it is called. As a result, a Clock is typically renderer as path/to/the/code.py:start-stop where start and stop are the line numbers of the tick and tock . You can name the beginning and end of timers: clock = tick ( \"beginning\" ) clock . tock ( \"end\" ) Which will then be displayed as \u23f1\ufe0f [beginning-end] 1ms count=1 Clock identity tick and tock function by recording the specific line in your code that they are created at. This allows ticktock to aggregate times together although the Clock is redefined everytime the code is visited: for _ in range ( 100 ): t = tick () # <- this is always the same object ... t . tock () id ( t ) # <- this is always the same value Context manager \u00b6 It is possible to use ticktock as a context manager to track the timing of a chunk of code: from ticktock import ticktock with ticktock (): time . sleep ( 1 ) Naming By default the name of the clock with a context manager is the filename and line numbers, but you can also provide a name to the context manager: with ticktock ( name = \"some name\" ): pass Function decorator \u00b6 ticktock doubles as a decorator that tracks the timing of each call to a function: from ticktock import ticktock @ticktock def f (): time . sleep ( 1 ) f () Naming Naming ticktock function decorators By default the name of the clock with a function decorator is the name of the function: @ticktock def f (): pass Will render as: \u23f1\ufe0f [f] 1ms count=1 You can also provide a name to the decorator @ticktock ( name = \"some name\" ) def f (): pass Will render as: \u23f1\ufe0f [some name] 1ms count=1 Multiple Clocks \u00b6 Of course, can create multiple independent ticks, which will appear as separate clocks: for _ in range ( 1000 ): clock = tick () # do some work time . sleep ( 1 ) clock . tock () clock = tick () # do some other work time . sleep ( 0.5 ) clock . tock () A clock can also have a multiple tocks , which will be displayed as different lines 1 2 3 4 5 6 7 t = tick ( \"start\" ) time . sleep ( 1 ) if k % 2 == 1 : time . sleep ( 1 ) t . tock ( \"one\" ) else : t . tock ( \"two\" ) Which will lead to two lines being renderered: \u23f1\ufe0f [start-one] 1s count=1 \u23f1\ufe0f [start-two] 2s count=1","title":"Using clocks"},{"location":"using_clocks/#advanced-timing","text":"ticktock gives you different ways to specify which parts of your code you want to time: functions, a decorator, or a context manager.","title":"Advanced timing"},{"location":"using_clocks/#tick-and-tock","text":"Use tick to create a Clock and signal the start of a measurement: from ticktock import tick t = tick () # t is a Clock instance Then, use the tock method to signal the end of the measurement for this clock: t . tock () Naming By default, tick creates a clock named after where it is first created (e.g. path/to/the/code.py:line_number ), and tock is named after the line in which it is called. As a result, a Clock is typically renderer as path/to/the/code.py:start-stop where start and stop are the line numbers of the tick and tock . You can name the beginning and end of timers: clock = tick ( \"beginning\" ) clock . tock ( \"end\" ) Which will then be displayed as \u23f1\ufe0f [beginning-end] 1ms count=1 Clock identity tick and tock function by recording the specific line in your code that they are created at. This allows ticktock to aggregate times together although the Clock is redefined everytime the code is visited: for _ in range ( 100 ): t = tick () # <- this is always the same object ... t . tock () id ( t ) # <- this is always the same value","title":"tick and tock"},{"location":"using_clocks/#context-manager","text":"It is possible to use ticktock as a context manager to track the timing of a chunk of code: from ticktock import ticktock with ticktock (): time . sleep ( 1 ) Naming By default the name of the clock with a context manager is the filename and line numbers, but you can also provide a name to the context manager: with ticktock ( name = \"some name\" ): pass","title":"Context manager"},{"location":"using_clocks/#function-decorator","text":"ticktock doubles as a decorator that tracks the timing of each call to a function: from ticktock import ticktock @ticktock def f (): time . sleep ( 1 ) f () Naming Naming ticktock function decorators By default the name of the clock with a function decorator is the name of the function: @ticktock def f (): pass Will render as: \u23f1\ufe0f [f] 1ms count=1 You can also provide a name to the decorator @ticktock ( name = \"some name\" ) def f (): pass Will render as: \u23f1\ufe0f [some name] 1ms count=1","title":"Function decorator"},{"location":"using_clocks/#multiple-clocks","text":"Of course, can create multiple independent ticks, which will appear as separate clocks: for _ in range ( 1000 ): clock = tick () # do some work time . sleep ( 1 ) clock . tock () clock = tick () # do some other work time . sleep ( 0.5 ) clock . tock () A clock can also have a multiple tocks , which will be displayed as different lines 1 2 3 4 5 6 7 t = tick ( \"start\" ) time . sleep ( 1 ) if k % 2 == 1 : time . sleep ( 1 ) t . tock ( \"one\" ) else : t . tock ( \"two\" ) Which will lead to two lines being renderered: \u23f1\ufe0f [start-one] 1s count=1 \u23f1\ufe0f [start-two] 2s count=1","title":"Multiple Clocks"}]}